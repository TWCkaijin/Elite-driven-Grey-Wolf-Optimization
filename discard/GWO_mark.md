# GWO 算法邏輯

## 0. 定義: 
0.1. 狼群: 一群狼的集合，每隻狼代表一個解(不一定正確)，狼群的總目標是找到最佳解。而狼群有分為領頭狼(alpha, beta, gamma)、隨機狼，這些狼的位置會隨著迭代而更新。

0.2. 狼群數量: 可以當作有幾個新的隨機參考點給領頭狼參考(每個iteration計算時需要更新狼位置的次數)

0.3. 狼群**位置**: 每隻狼的位置會依照維度而有所不同

0.4. 狼群的**目標函數值**: 每隻狼對於假想最佳解的距離，目標函數值越小表示距離最佳解越近

0.5. 狼群**更新**: 領頭狼除外(特殊算法)，隨機狼在領頭狼附近隨機更新。

0.6. **領頭狼**: 必須是距離最佳解最近的三隻狼且永遠 Alpha < Beta < Gamma (所以Alpha最近)。
如果不是最近，那麼會在下一個iteration時將最近的隨機狼與其做對換。



## 1. 初始化群體(初始化整個演算法)
1.1. 初始化狼群數量

1.2. 初始化狼群位置 : 根據維度給予每隻狼隨機的位置(注意UB和LB)

1.3. 初始化狼群的目標函數值 : 也就是每隻狼當前對於假想最佳解的距離

## 2. 運行迭代
2.1.  **更新領頭狼**(三隻): 如果有任何一隻隨機狼的目標函數值小於三隻領頭狼，就將隨機狼與不合格的領頭狼更換位置。使其永遠符合 "三隻狼距離最佳解最近的永遠 Alpha < Beta < Gamma"

2.2. **更新隨機狼**(N隻): 隨機狼的更新公式如下
>1. 先計算 a 值(時間參數): 
``` cpp
    a = 2.0 * (1.0 - (iter / (double)MAX_ITER))
```
</br>

>2. 計算A1,A2,A3(領頭狼隨機參數): 
``` cpp 
    A1 = a * (2 * ((double)rand() / RAND_MAX) - 1);
    // A2, A3 相同
```
</br>

>3. 計算C1, C2, C3(位置隨機權重參數):
```cpp
    C1 = 2 * ((double)rand() / RAND_MAX);
    // C2 , C3 相同
```
</br>

>4. 計算自己與三隻領頭狼的距離參數:
```cpp
    D_alpha = fabs(C1 * alpha[j] - current_wolve[j]); //當前隨機狼與aplha領頭狼距離
    D_beta = fabs(C2 * beta[j] - current_wolve[j]);
    D_gamma = fabs(C3 * gamma[j] - current_wolve[j]);
```
</br>

>5. 計算自己要朝三隻領頭狼移動目標點 (舉例: X1 是根據alpha的位置計算出的下一個目標移動點)
```cpp
    X1 = alpha[j] - A1 * D_alpha;
    X2 = beta[j] - A2 * D_beta;
    X3 = gamma[j] - A3 * D_gamma;
```
</br>

>6. 平均三個目標點並檢查正確性
```cpp
    wolves[i][j] = (X1 + X2 + X3) / 3; // 平均三個目標點
    
    //注意上限下限
    if (wolves[i][j] < LB) wolves[i][j] = LB; 
    if (wolves[i][j] > UB) wolves[i][j] = UB;
```
</br>

>7. 更新目標適應函數(上面的做法只有計算一個維度，計算完所有維度方可更新)
```cpp
    fitness[i] = fitnessFunction(wolves[i]);
```
</br>

>8. 重複更新不同狼隻

2.3. **重複上述步驟直到MAX_iter**


